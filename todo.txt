#!/bin/bash

# Set the variables for role ID and secret ID
ROLE_ID="your_role_id"
SECRET_ID="your_secret_id"

# Authenticate with Vault and retrieve the client token
AUTH_RESPONSE=$(curl --request POST --data "{\"role_id\": \"$ROLE_ID\", \"secret_id\": \"$SECRET_ID\"}" \
  https://your-vault-url/v1/auth/approle/login)
CLIENT_TOKEN=$(echo "$



==============================

#!/bin/bash

# Set the variables for role ID and secret ID
ROLE_ID="your_role_id"
SECRET_ID="your_secret_id"

# Authenticate with Vault and retrieve the client token
AUTH_RESPONSE=$(curl --request POST --data "{\"role_id\": \"$ROLE_ID\", \"secret_id\": \"$SECRET_ID\"}" \
  https://your-vault-url/v1/auth/approle/login)
CLIENT_TOKEN=$(echo "$AUTH_RESPONSE" | jq -r '.auth.client_token')

# Fetch secret data using the client token
SECRET_RESPONSE=$(curl --header "X-Vault-Token: $CLIENT_TOKEN" \
  https://your-vault-url/v1/secret/data/your_secret_path)
SECRET_DATA=$(echo "$SECRET_RESPONSE" | jq -r '.data.data')

# Display the secret data
echo "$SECRET_DATA"
====================

#!/bin/bash

# Set the variables for role ID and secret ID
ROLE_ID="your_role_id"
SECRET_ID="your_secret_id"

# Authenticate with Vault and retrieve the client token
AUTH_RESPONSE=$(curl --silent --request POST --data "{\"role_id\": \"$ROLE_ID\", \"secret_id\": \"$SECRET_ID\"}" \
  https://your-vault-url/v1/auth/approle/login)
CLIENT_TOKEN=$(echo "$AUTH_RESPONSE" | sed -n 's/.*"client_token":"\([^"]*\)".*/\1/p')

# Fetch secret data using the client token
SECRET_RESPONSE=$(curl --silent --header "X-Vault-Token: $CLIENT_TOKEN" \
  https://your-vault-url/v1/secret/data/your_secret_path)
SECRET_DATA=$(echo "$SECRET_RESPONSE" | sed -n 's/.*"data":{"data":\([^}]*\)}.*/\1/p')

# Display the secret data
echo "$SECRET_DATA"




=========================
#!/bin/bash

# Set the variables for role ID and secret ID
ROLE_ID="your_role_id"
SECRET_ID="your_secret_id"

# Authenticate with Vault and retrieve the client token
AUTH_RESPONSE=$(curl --silent --request POST --data "{\"role_id\": \"$ROLE_ID\", \"secret_id\": \"$SECRET_ID\"}" \
  https://your-vault-url/v1/auth/approle/login)
CLIENT_TOKEN=$(echo "$AUTH_RESPONSE" | awk -F'"' '{print $10}')

# Fetch secret data using the client token
SECRET_RESPONSE=$(curl --silent --header "X-Vault-Token: $CLIENT_TOKEN" \
  https://your-vault-url/v1/secret/data/your_secret_path)
SECRET_DATA=$(echo "$SECRET_RESPONSE" | awk -F'"' '{print $12}')

# Display the secret data
echo "$SECRET_DATA"



==============================

#!/bin/bash

# Set the variables for role ID and secret ID
ROLE_ID="your_role_id"
SECRET_ID="your_secret_id"

# Authenticate with Vault and retrieve the client token
AUTH_RESPONSE=$(curl --silent --request POST --data "{\"role_id\": \"$ROLE_ID\", \"secret_id\": \"$SECRET_ID\"}" \
  https://your-vault-url/v1/auth/approle/login)
CLIENT_TOKEN=$(echo "$AUTH_RESPONSE" | grep -o '"client_token":"[^"]*' | cut -d'"' -f4)

# Fetch secret data using the client token
SECRET_RESPONSE=$(curl --silent --header "X-Vault-Token: $CLIENT_TOKEN" \
  https://your-vault-url/v1/secret/data/your_secret_path)
SECRET_DATA=$(echo "$SECRET_RESPONSE" | grep -o '"data":{"data":{"[^}]*' | cut -d'"' -f8)

# Display the secret data
echo "$SECRET_DATA"


==========
import subprocess

# Command to append supervisord entry to crontab
command = '(crontab -l 2>/dev/null; echo "@reboot supervisord -c /path/to/supervisord.conf") | crontab -'

# Execute the command
subprocess.run(command, shell=True)



++++++++++++++++++++++++++++++++++++
import subprocess

# Define the command to add a cron job
command = "echo '*/5 * * * * python /path/to/script.py' | crontab -"

# Execute the command in the terminal
subprocess.call(command, shell=True)


============================================

import os

# Define the cron job entry
cron_entry = "*/5 * * * * python /path/to/script.py\n"  # Replace with the desired cron job entry

# Open the crontab file in append mode
with open('temp_cron', 'a') as file:
    # Write the new cron job entry
    file.write(cron_entry)

# Load the updated crontab file
os.system('crontab temp_cron')

# Remove the temporary file
os.remove('temp_cron')



==================================
import os

# Define the cron job entry
cron_entry = "*/5 * * * * python /path/to/script.py"  # Replace with the desired cron job entry

# Get the current user's crontab
os.system('crontab -l > temp_cron')

# Open the temporary crontab file in append mode
with open('temp_cron', 'a') as file:
    # Write the new cron job entry
    file.write(cron_entry + '\n')

# Load the updated crontab from the temporary file
os.system('crontab temp_cron')

# Remove the temporary file
os.remove('temp_cron')


==============================
import urllib.request
import zipfile

# URL of the file to download
url = "https://example.com/archive.zip"  # Replace with the actual URL of the file

# Path to save the downloaded file
file_path = "/path/to/save/archive.zip"  # Replace with the desired save location

# Download the file
urllib.request.urlretrieve(url, file_path)

# Extract the downloaded file
with zipfile.ZipFile(file_path, 'r') as zip_ref:
    zip_ref.extractall("/path/to/extract")  # Replace with the desired extraction location


=================================================

import urllib.request
import shutil
import os
import zipfile

# URL of the file to download
url = "https://example.com/archive.zip"  # Replace with the actual URL of the file

# Path to save the downloaded file
file_path = "/path/to/save/archive.zip"  # Replace with the desired save location

# Path to extract the downloaded file
extract_path = "/path/to/extract"  # Replace with the desired extraction location

# Download the file
with urllib.request.urlopen(url) as response, open(file_path, 'wb') as out_file:
    shutil.copyfileobj(response, out_file)

# Extract the downloaded file
with zipfile.ZipFile(file_path, 'r') as zip_ref:
    zip_ref.extractall(extract_path)

# Remove the downloaded zip file
os.remove(file_path)


===============================
import urllib.request
import os
import zipfile

# Artifactory URL and authentication credentials
artifactory_url = "https://example.com/artifactory/repo/archive.zip"  # Replace with the actual Artifactory URL
username = "your_username"  # Replace with your Artifactory username
password = "your_password"  # Replace with your Artifactory password

# Path to save the downloaded file
file_path = "/path/to/save/archive.zip"  # Replace with the desired save location

# Path to extract the downloaded file
extract_path = "/path/to/extract"  # Replace with the desired extraction location

# Create a password manager and add credentials
password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()
password_mgr.add_password(None, artifactory_url, username, password)

# Create a handler with the password manager
handler = urllib.request.HTTPBasicAuthHandler(password_mgr)

# Create an opener with the handler
opener = urllib.request.build_opener(handler)

# Install the opener
urllib.request.install_opener(opener)

# Download the file
urllib.request.urlretrieve(artifactory_url, file_path)

# Extract the downloaded file
with zipfile.ZipFile(file_path, 'r') as zip_ref:
    zip_ref.extractall(extract_path)

# Remove the downloaded zip file
os.remove(file_path)


=============================

import urllib.request
import os
import zipfile

# Artifactory URL and access token
artifactory_url = "https://example.com/artifactory/repo/archive.zip"  # Replace with the actual Artifactory URL
access_token = "your_access_token"  # Replace with your Artifactory access token

# Path to save the downloaded file
file_path = "/path/to/save/archive.zip"  # Replace with the desired save location

# Path to extract the downloaded file
extract_path = "/path/to/extract"  # Replace with the desired extraction location

# Create a password manager with the access token
password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()
password_mgr.add_password(None, artifactory_url, access_token, "")

# Create a handler with the password manager
handler = urllib.request.HTTPBasicAuthHandler(password_mgr)

# Create an opener with the handler
opener = urllib.request.build_opener(handler)

# Install the opener
urllib.request.install_opener(opener)

# Download the file
urllib.request.urlretrieve(artifactory_url, file_path)

# Extract the downloaded file
with zipfile.ZipFile(file_path, 'r') as zip_ref:
    zip_ref.extractall(extract_path)

# Remove the downloaded zip file
os.remove(file_path)



========================


To obtain an access token for JFrog Artifactory, you can follow these steps:

    Open your JFrog Artifactory instance in a web browser.
    Log in to your Artifactory account with appropriate credentials.
    Once logged in, navigate to your user profile or account settings.
    Look for an option related to "API Keys" or "Access Tokens". The specific location may vary depending on the Artifactory version and configuration.
    Generate a new access token by providing a name or description for the token.
    Customize the token's permissions or scopes based on your requirements. For example, you may grant read-only or read-write access to specific repositories or actions.
    Save or copy the generated access token. Note that some systems only display the token once, so make sure to store it securely.

Once you have obtained the access token, you can use it in your Python code for authentication with the JFrog Artifactory, as shown in the previous examples. Replace the "your_access_token" placeholder with your actual access token in the code.



import os
import urllib3
import zipfile

def download_and_extract(url, destination_folder):
    # Create the destination folder if it doesn't exist
    if not os.path.exists(destination_folder):
        os.makedirs(destination_folder)

    # Set up the urllib3 PoolManager
    http = urllib3.PoolManager()

    # Download the file
    file_name = os.path.join(destination_folder, url.split("/")[-1])
    with http.request("GET", url, preload_content=False) as response, open(file_name, "wb") as out_file:
        out_file.write(response.data)

    # Extract the contents of the downloaded file
    with zipfile.ZipFile(file_name, "r") as zip_ref:
        zip_ref.extractall(destination_folder)

    # Remove the downloaded zip file
    os.remove(file_name)

# Example usage:
url = "https://example.com/archive.zip"
destination_folder = "/path/to/folder"

download_and_extract(url, destination_folder)



===========================
def check_crontab_entry(cron_entry):
    try:
        with open('/tmp/crontab_temp', 'w') as temp_file:
            # Save the current user's crontab to a temporary file
            os.system('crontab -l > /tmp/crontab_temp')

        with open('/tmp/crontab_temp', 'r') as temp_file:
            for line in temp_file:
                if cron_entry in line:
                    return True
        return False
    except FileNotFoundError:
        return False

def add_crontab_entry(cron_entry):
    with open('/tmp/crontab_temp', 'a') as temp_file:
        temp_file.write(cron_entry + '\n')

    # Update the user's crontab with the temporary file
    os.system('crontab /tmp/crontab_temp')

def main():
    # Define the cron entry to add
    cron_entry = "@reboot supervisord -c /path/to/supervisord.conf"

    # Check if the entry already exists in the crontab
    entry_exists = check_crontab_entry(cron_entry)

    if entry_exists:
        print("Cron entry already exists. No changes needed.")
    else:
        # Append the cron entry to the temporary crontab file
        add_crontab_entry(cron_entry)
        print("Cron entry added successfully.")

if __name__ == "__main__":
    import os
    main()


====================================
def check_crontab_entry(cron_entry):
    try:
        with open('/tmp/crontab_temp', 'w') as temp_file:
            # Save the current user's crontab to a temporary file
            subprocess.run('crontab -l', stdout=temp_file, shell=True)

        with open('/tmp/crontab_temp', 'r') as temp_file:
            for line in temp_file:
                if cron_entry in line:
                    return True
        return False
    except FileNotFoundError:
        return False

def add_crontab_entry(cron_entry):
    with open('/tmp/crontab_temp', 'a') as temp_file:
        temp_file.write(cron_entry + '\n')

    # Update the user's crontab with the temporary file
    subprocess.run('crontab /tmp/crontab_temp', shell=True)

def main():
    # Define the cron entry to add
    cron_entry = "@reboot supervisord -c /path/to/supervisord.conf"

    # Check if the entry already exists in the crontab
    entry_exists = check_crontab_entry(cron_entry)

    if entry_exists:
        print("Cron entry already exists. No changes needed.")
    else:
        # Append the cron entry to the temporary crontab file
        add_crontab_entry(cron_entry)
        print("Cron entry added successfully.")

if __name__ == "__main__":
    main()


--------------------------------------------

def read_text_file(file_path):
    with open(file_path, 'r') as file:
        lines = file.readlines()
        return [line.strip() for line in lines if line.strip() != '']

def remove_entries_from_list(source_list, removal_list):
    return [entry for entry in source_list if entry not in removal_list]

def add_entries_to_list(source_list, entry_list):
    return source_list + [entry for entry in entry_list if entry not in source_list]

def write_list_to_file(file_path, data_list):
    with open(file_path, 'w') as file:
        file.write('\n'.join(data_list))

def main():
    # Define the file paths and lists
    input_file_path = 'input.txt'
    output_file_path = 'output.txt'
    cron_entry = ['entry1', 'entry2', 'entry3']  # Replace with your cron_entry list
    cron_entry_removal = ['entry2', 'entry4']    # Replace with your cron_entry_removal list

    # Step 1: Read the text file and create the initial list
    file_list = read_text_file(input_file_path)

    # Step 2: Remove entries from file_list if they exist in cron_entry_removal
    file_list = remove_entries_from_list(file_list, cron_entry_removal)

    # Step 3: Add entries from cron_entry to file_list if they don't already exist
    file_list = add_entries_to_list(file_list, cron_entry)

    # Step 4: Write the updated file_list to a new file
    write_list_to_file(output_file_path, file_list)

if __name__ == "__main__":
    main()


--------------------------------------------

def read_text_file(file_path):
    with open(file_path, 'r') as file:
        lines = file.readlines()
        return {line.strip() for line in lines if line.strip() != ''}

def write_list_to_file(file_path, data_set):
    with open(file_path, 'w') as file:
        file.write('\n'.join(data_set))

def main():
    # Define the file paths and sets
    input_file_path = 'input.txt'
    output_file_path = 'output.txt'
    cron_entry = {'entry1', 'entry2', 'entry3'}  # Replace with your cron_entry set
    cron_entry_removal = {'entry2', 'entry4'}    # Replace with your cron_entry_removal set

    # Step 1: Read the text file and create the initial set
    file_set = read_text_file(input_file_path)

    # Step 2: Remove entries from file_set if they exist in cron_entry_removal
    file_set -= cron_entry_removal

    # Step 3: Add entries from cron_entry to file_set if they don't already exist
    file_set |= cron_entry

    # Step 4: Write the updated file_set to a new file
    write_list_to_file(output_file_path, file_set)

if __name__ == "__main__":
    main()

--------------------------------------------

def read_text_file(file_path):
    with open(file_path, 'r') as file:
        lines = file.readlines()
        return {line.strip() for line in lines if line.strip() != ''}

def write_list_to_file(file_path, data_set):
    with open(file_path, 'w') as file:
        file.write('\n'.join(data_set))

def main():
    # Define the file paths and sets
    input_file_path = 'input.txt'
    output_file_path = 'output.txt'
    cron_entry = {'entry1', 'entry2', 'entry3'}  # Replace with your cron_entry set
    cron_entry_removal = {'entry2', 'entry4'}    # Replace with your cron_entry_removal set

    # Step 1: Read the text file and create the initial set
    file_set = read_text_file(input_file_path)

    # Step 2: Remove entries from file_set if they exist in cron_entry_removal
    file_set -= cron_entry_removal

    # Step 3: Add entries from cron_entry to file_set if they don't already exist
    file_set |= cron_entry

    # Step 4: Write the updated file_set to a new file
    write_list_to_file(output_file_path, file_set)

if __name__ == "__main__":
    main()


---------------------------------------------

*****************************************************************
import subprocess

def execute_and_log_command(command):
    try:
        # Execute the command and capture the output and errors
        result = subprocess.run(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        
        # Log the command output and errors
        with open('command_log.txt', 'a') as log_file:
            log_file.write(f"Command: {command}\n")
            log_file.write(f"Exit Code: {result.returncode}\n")
            log_file.write(f"Output:\n{result.stdout}\n")
            log_file.write(f"Errors:\n{result.stderr}\n")
            log_file.write('=' * 50 + '\n')

        return result.returncode, result.stdout, result.stderr
    except Exception as e:
        return -1, None, str(e)

# Define the system command to execute
command = "ps -ef -u edapi | grep python | grep udafdbi | awk '{print $2}' | xargs kill -9"

# Execute the command and log the output
exit_code, stdout, stderr = execute_and_log_command(command)

if exit_code == 0:
    print("Command executed successfully!")
else:
    print("Command execution failed. Check the log for details.")


---------------------------------------

import subprocess

def execute_and_print_command(command):
    try:
        # Execute the command and capture the output
        result = subprocess.run(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        
        # Print the command output
        print("Command Output:")
        print(result.stdout)
        
        if result.returncode == 0:
            print("Command executed successfully!")
        else:
            print("Command execution failed.")
        
        # Print any errors
        if result.stderr:
            print("Errors:")
            print(result.stderr)
            
    except Exception as e:
        print("An error occurred:", str(e))

# Define the system command to execute
command = "ps -ef -u edapi | grep python | grep udafdbi | awk '{print $2}' | xargs kill -9"

# Execute the command and print the output
execute_and_print_command(command)











