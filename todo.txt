import os
import subprocess
import paramiko

def connect_to_remote(hostname, port, username, password):
    ssh_client = paramiko.SSHClient()
    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    ssh_client.connect(hostname, port=port, username=username, password=password)
    print(f"Connected to {hostname}")
    return ssh_client

def disconnect_from_remote(ssh_client):
    if ssh_client:
        ssh_client.close()
        print("Disconnected from the remote host")

def backup_file(port):
    source_file = ""
    dest_file = ""

    if port == 500:
        source_file = "/home/config/file1.txt"
        dest_file = "/home/config/file.bkp"
    elif port == 700:
        source_file = "/home/config/conf.txt"
        dest_file = "/home/config/conf.bkp"

    if source_file and dest_file:
        subprocess.run(["cp", source_file, dest_file])
        print(f"Backup created: {source_file} -> {dest_file}")
    else:
        print("Invalid port number")

def add_ldap_group(ssh_client):
    ldap_group = "DYFP_MYSD_HRPA,OU=Groups,OU=DT,"
    command = f'echo "{ldap_group}" >> /home/ldap/ro.conf'
    ssh_client.exec_command(command)
    print(f"LDAP group added to /home/ldap/ro.conf: {ldap_group}")

def create_command_file():
    command_content = "//create file\nuse admin\ndb.create role()\npriveleges:"
    with open("/home/commands/first.cmd", "w") as cmd_file:
        cmd_file.write(command_content)
    print("Command file created: /home/commands/first.cmd")

def chmod_command_file():
    subprocess.run(["chmod", "700", "/home/commands/first.cmd"])
    print("Command file chmoded to 700: /home/commands/first.cmd")

def execute_shell_script(ssh_client, port, role):
    script_path = "/home/sheel/scripts/create.ksh"
    command = f"{script_path} -p {port} -r {role}"
    ssh_client.exec_command(command)
    print(f"Shell script executed: {command}")

def check_role_creation(ssh_client, port, role):
    script_path = "/home/sheel/scripts/show_roles.ksh"
    command = f"{script_path} -p {port} -r {role}"
    _, stdout, _ = ssh_client.exec_command(command)
    output = stdout.read().decode('utf-8')
    print("Output of show_roles.ksh:")
    print(output)

def main():
    with open("lists.txt", "r") as file:
        for line in file:
            data = line.strip().split(',')
            hostname, port, username, password = data
            port = int(port)

            # Connect to remote host
            ssh_client = connect_to_remote(hostname, port, username, password)

            # Perform activities
            backup_file(port)
            add_ldap_group(ssh_client)
            create_command_file()
            chmod_command_file()
            execute_shell_script(ssh_client, port, "dtca")
            check_role_creation(ssh_client, port, "dtca")

            # Disconnect from remote host
            disconnect_from_remote(ssh_client)

if __name__ == "__main__":
    main()



import configparser

def compare_config_files(file1, file2):
    config1 = configparser.ConfigParser()
    config2 = configparser.ConfigParser()

    config1.read(file1)
    config2.read(file2)

    sections1 = set(config1.sections())
    sections2 = set(config2.sections())

    common_sections = sections1.intersection(sections2)
    different_sections = sections1.symmetric_difference(sections2)

    print("Common Sections:")
    print(common_sections)
    print("\nDifferent Sections:")
    print(different_sections)

    for section in common_sections:
        options1 = set(config1.options(section))
        options2 = set(config2.options(section))

        common_options = options1.intersection(options2)
        different_options = options1.symmetric_difference(options2)

        print(f"\nSection: {section}")
        print("Common Options:")
        print(common_options)
        print("Different Options:")
        print(different_options)

        for option in common_options:
            value1 = config1.get(section, option)
            value2 = config2.get(section, option)

            if value1 != value2:
                print(f"Difference in value for option '{option}':")
                print(f"  {file1}: {value1}")
                print(f"  {file2}: {value2}")

if __name__ == "__main__":
    file1_path = "config1.ini"
    file2_path = "config2.ini"

    compare_config_files(file1_path, file2_path)



import argparse
import re
import difflib
import sys

allowLogs = True  # Set this variable to True or False as needed

# Exceptions: Specify the keywords that the statements in your code start with.
# For example, if a statement in your code is "server_id = 103", you can specify "server_id" as an exception.
exceptions = []

# Display additional info about data processing


def log_print(*args):
    if allowLogs:
        print("------", *args, '\n')

# Remove newline characters from the line


def filterLine(line: str):
    filteredLine = re.sub(r"(\n|\\n|\r)+", "", line)
    return filteredLine.strip()

# Filter out empty strings from the list


def filterList(lst: list):
    filteredList = [line for line in lst if line != ""]
    return filteredList

# Checks whether line starts with exception keyword


def isLineHaveException(line: str):
    if exceptions:
        for excp in exceptions:
            if line.startswith(excp):
                return True
    return False

# Compare the contents of two files


def differ(file1, file2):
    global exceptions

    print(f"\nComparing {file1} and {file2}")

    if file_exceptions:
        exceptions = [excp.strip('[').strip(',').strip(']')
                      for excp in file_exceptions]
        log_print(f"Exceptions: {exceptions}")
    else:
        log_print('There are no exceptions')

    try:
        # Attempt to open the files
        with open(file1_path, 'r') as firstFile, open(file2_path, 'r') as secondFile:
            # Read the lines from the files
            raw_file1_lines = firstFile.readlines()
            raw_file2_lines = secondFile.readlines()

    except FileNotFoundError as e:
        log_print(f"Error: {e}")
        sys.exit(1)  # Terminate the script with a non-zero exit code

    # Check if the files are identical
    if raw_file1_lines == raw_file2_lines:
        return "No differences found\n"

    # Filter the lines in each file
    filtered_file1_lines = [filterLine(line) for line in raw_file1_lines]
    filtered_file2_lines = [filterLine(line) for line in raw_file2_lines]

    # Filter out empty lines
    filtered_file1_lines = filterList(filtered_file1_lines)
    filtered_file2_lines = filterList(filtered_file2_lines)

    # Check if the filtered files are identical
    if filtered_file1_lines == filtered_file2_lines:
        return "No differences found\n"

    # Find the differences between the files
    maxLines = max(len(filtered_file1_lines), len(filtered_file2_lines))
    lineCounter = 0
    totalDifferences = 0

    while lineCounter < maxLines:
        try:
            file1_line = filtered_file1_lines[lineCounter]
            file2_line = filtered_file2_lines[lineCounter]

            if file1_line != file2_line:
                # Check for exceptions
                if isLineHaveException(file1_line) and isLineHaveException(file2_line):
                    log_print('EXCEPTION:', file1_line, '\n', file2_line)
                else:
                    print(
                        f'The difference N-{lineCounter}:\n File {file1}: In < {file1_line} > \n File {file2}: In < {file2_line} >\n')

                    totalDifferences += 1

        except IndexError:
            # If the line numbers are not equal
            moreLineFile = filtered_file1_lines if len(
                filtered_file1_lines) == maxLines else filtered_file2_lines

            larger_file = file1 if moreLineFile == filtered_file1_lines else file2
            print(
                f'Only file {larger_file} has: < {moreLineFile[lineCounter]} >\n')
            totalDifferences += 1

        lineCounter += 1

    print(f"Total Differences Found: {totalDifferences}")

    # Return difference percentage
    matcher = difflib.SequenceMatcher(
        None, filtered_file1_lines, filtered_file2_lines)
    fileSimilarity = round(matcher.ratio() * 100, 2)
    return f"Files equal: {fileSimilarity}%"


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Compare two files.")
    parser.add_argument(
        "--file1", help="Path to the first file", required=True)
    parser.add_argument(
        "--file2", help="Path to the second file", required=True)
    parser.add_argument(
        "--exceptions",
        nargs="*",
        help=("Exception lines that are not counted")
    )
    args = parser.parse_args()

    file1_path = args.file1
    file2_path = args.file2
    file_exceptions = args.exceptions

    try:
        print(differ(file1_path, file2_path))
    except Exception as e:
        print(f"An error occurred: {e}")









import os
import shutil
from datetime import datetime

def manage_file(file_path):
    # Define folder names
    bak_folder = 'bak'
    storage_folder = 'storage'
    
    # Create folders if they do not exist
    os.makedirs(bak_folder, exist_ok=True)
    os.makedirs(storage_folder, exist_ok=True)
    
    # Get the filename from the file path
    filename = os.path.basename(file_path)
    print(filename)
    
    # Paths for storage and backup files
    storage_file_path = os.path.join(storage_folder, filename)
    print(storage_file_path)
    backup_files_pattern = os.path.join(bak_folder, f"{filename}*")
    print(backup_files_pattern)
    
    if os.path.exists(storage_file_path):
        # Find all backups of this file
        backups = [f for f in os.listdir(bak_folder) if f.startswith(filename)]
        backups.sort()  # Oldest files first due to lexicographical sort

        # Check and delete the oldest backup if there are already 3 backups
        if len(backups) >= 3:
            os.remove(os.path.join(bak_folder, backups[0]))

        # Create a new backup
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        backup_file_path = os.path.join(bak_folder, f"{filename}.{timestamp}")
        shutil.copy2(storage_file_path, backup_file_path)

        # Overwrite the file in storage with the input file
        shutil.copy2(file_path, storage_file_path)
    else:
        # If the file is not present in storage, store it
        shutil.copy2(file_path, storage_file_path)

# Example usage
manage_file(r'C:\WORK\Lang\Python\CodePractise\new.env')
